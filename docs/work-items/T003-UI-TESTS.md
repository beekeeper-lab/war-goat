# Test: End-to-End UI Tests with Playwright MCP

> **ID**: T003
> **Type**: Test
> **Status**: Planned
> **Priority**: High
> **Effort**: L
> **Created**: 2026-01-16
> **Blocked By**: None
> **MCP Required**: Playwright MCP (configured!)

## Overview

Add end-to-end UI tests using Playwright with AI-assisted test generation via Playwright MCP. This enables Claude to both write AND execute tests, with self-healing locators and accessibility-tree based element selection.

---

## Why Playwright MCP?

Traditional E2E testing vs AI-assisted:

| Aspect | Traditional Playwright | Playwright MCP |
|--------|----------------------|----------------|
| Locator strategy | Manual CSS/XPath | Accessibility tree (auto) |
| When DOM changes | Tests break | Self-healing locators |
| Test creation | Manual coding | AI generates + validates |
| Debugging | Screenshots, traces | AI explains failures |
| Maintenance | High | Low (AI adapts) |

**Key benefit**: Claude can write a test, run it via MCP, see if it passes, and fix it - all in one conversation.

---

## MCP Configuration

Already added to `.mcp.json`:

```json
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["-y", "@playwright/mcp@latest"]
    }
  }
}
```

### Available MCP Tools

| Tool | Purpose |
|------|---------|
| `browser_navigate` | Navigate to URL |
| `browser_click` | Click element (by accessibility role/name) |
| `browser_type` | Type text into input |
| `browser_snapshot` | Get accessibility tree snapshot |
| `browser_screenshot` | Capture screenshot |
| `browser_wait` | Wait for condition |
| `browser_evaluate` | Run JavaScript in page |

---

## Test Scope

### Critical User Flows

#### 1. Add Interest Flow

**AI Prompt for Test Generation**:
```
Using Playwright MCP, write and run an E2E test that:
1. Opens War Goat at http://localhost:5173
2. Clicks the "Add Interest" button
3. Enters a YouTube URL in the modal
4. Clicks Add and waits for enrichment
5. Verifies a new card appears with the video title
```

**Expected test behavior**:
- [ ] Navigate to app
- [ ] Click add button (found via accessibility role)
- [ ] Modal opens
- [ ] Type URL in textbox
- [ ] Submit form
- [ ] Wait for new card to appear
- [ ] Verify enriched data displayed

#### 2. View Interest Details Flow

**AI Prompt**:
```
Test the detail view flow:
1. Click on any interest card
2. Verify detail panel opens
3. Check that title, URL, and status are displayed
4. If transcript available, expand and verify it loads
5. Close the panel
```

**Expected test behavior**:
- [ ] Click card element
- [ ] Detail panel visible
- [ ] All metadata fields present
- [ ] Transcript lazy-loads on expand
- [ ] Close button works

#### 3. Filter and Search Flow

**AI Prompt**:
```
Test filtering:
1. Note the initial count of cards
2. Select "YouTube" from the type filter
3. Verify fewer or equal cards shown
4. Add a search term
5. Verify results match search
6. Clear filters and verify original count
```

#### 4. Update Status Flow

**AI Prompt**:
```
Test status updates:
1. Open detail view for an item
2. Change status from "Backlog" to "In Progress"
3. Verify the status badge updates
4. Filter by "In Progress" status
5. Verify the item appears in filtered list
```

#### 5. Delete Interest Flow

**AI Prompt**:
```
Test deletion:
1. Note the current card count
2. Click delete on any card
3. Confirm the deletion dialog
4. Verify card is removed
5. Verify count decreased by 1
```

---

## Hybrid Approach: AI + Traditional Tests

### When to Use Each

| Use Case | Approach |
|----------|----------|
| Exploratory testing | AI via MCP (interactive) |
| Regression suite | Traditional Playwright scripts |
| Flaky test debugging | AI analyzes and fixes |
| New feature testing | AI writes first draft, human refines |
| CI/CD pipeline | Traditional scripts |

### Traditional Test Structure (for CI)

```
e2e/
├── playwright.config.ts
├── fixtures/
│   └── test-data.ts
├── tests/
│   ├── add-interest.spec.ts
│   ├── view-details.spec.ts
│   ├── filter-search.spec.ts
│   ├── update-status.spec.ts
│   └── delete-interest.spec.ts
└── utils/
    └── helpers.ts
```

### AI-Generated Test Example

When you ask Claude to write a test via MCP, it produces something like:

```typescript
// Generated by Claude using Playwright MCP
import { test, expect } from '@playwright/test';

test.describe('Add Interest Flow', () => {
  test('should add a YouTube video successfully', async ({ page }) => {
    // Navigate to app
    await page.goto('http://localhost:5173');

    // Click add button - uses accessibility name
    await page.getByRole('button', { name: /add interest/i }).click();

    // Verify modal opened
    await expect(page.getByRole('dialog')).toBeVisible();

    // Enter YouTube URL
    await page.getByRole('textbox').fill('https://www.youtube.com/watch?v=dQw4w9WgXcQ');

    // Submit
    await page.getByRole('button', { name: /^add$/i }).click();

    // Wait for enrichment and modal close
    await expect(page.getByRole('dialog')).toBeHidden({ timeout: 15000 });

    // Verify new card with video title
    await expect(page.getByText(/rick astley/i)).toBeVisible();
  });
});
```

**Key difference**: AI uses `getByRole` and accessibility-based selectors automatically, which are more resilient than CSS selectors.

---

## Technical Setup

### Playwright Configuration

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e/tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },
});
```

### Package.json Scripts

```json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:debug": "playwright test --debug",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:report": "playwright show-report"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0"
  }
}
```

---

## AI-Assisted Testing Workflow

### 1. Write Tests with Claude

```
You: "Write an E2E test for the filter functionality"

Claude: [Uses Playwright MCP to:]
  1. Navigate to the app
  2. Take accessibility snapshot
  3. Identify filter controls
  4. Write test code
  5. Run it to verify it works
  6. Return working test file
```

### 2. Debug Failing Tests

```
You: "This test is failing, can you fix it?"

Claude: [Uses Playwright MCP to:]
  1. Run the failing test
  2. Take screenshot at failure point
  3. Get accessibility snapshot
  4. Identify what changed
  5. Update selectors automatically
  6. Re-run to verify fix
```

### 3. Exploratory Testing

```
You: "Explore the app and find any bugs"

Claude: [Uses Playwright MCP to:]
  1. Navigate through all pages
  2. Try various user flows
  3. Report any errors or unexpected behavior
  4. Suggest test cases for edge cases found
```

---

## Acceptance Criteria

- [ ] Playwright MCP configured and working
- [ ] All 5 critical user flows have tests
- [ ] Tests run on Chrome, Firefox, Safari
- [ ] Mobile viewport tests included
- [ ] Tests complete in < 3 minutes
- [ ] CI pipeline runs tests on PR
- [ ] AI can write new tests via conversation
- [ ] AI can debug and fix failing tests
- [ ] Self-healing locators demonstrated
- [ ] Test coverage report generated

---

## Example: AI-Assisted Test Session

```
Human: Let's test the add interest flow. Use Playwright MCP to verify it works.

Claude: I'll test the add interest flow using Playwright MCP.

[Calls browser_navigate to http://localhost:5173]
✓ Page loaded successfully

[Calls browser_snapshot to see page structure]
Found: Header with "Add Interest" button, interest grid with 5 cards

[Calls browser_click on "Add Interest" button]
✓ Modal opened

[Calls browser_snapshot]
Found: Dialog with URL input, Add and Cancel buttons

[Calls browser_type to enter YouTube URL]
✓ URL entered

[Calls browser_click on "Add" button]
✓ Form submitted

[Waits, then calls browser_snapshot]
✓ Modal closed, new card visible with enriched data

Test passed! Here's the generated test file:
[provides test code]
```

---

## CI Integration

```yaml
# .github/workflows/e2e.yml
name: E2E Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Start server
        run: npm run dev &

      - name: Wait for server
        run: npx wait-on http://localhost:5173

      - name: Run E2E tests
        run: npm run test:e2e

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-screenshots
          path: test-results/
          retention-days: 7
```

---

## Dependencies

- `@playwright/test` - Test framework
- `@playwright/mcp` - MCP server (via npx)
- Playwright browsers (auto-installed)

---

## Notes

- Playwright MCP uses accessibility tree, not screenshots - faster and more reliable
- AI-generated tests use `getByRole` which survives DOM changes
- Keep traditional test files for CI, use MCP for development/debugging
- First run auto-installs browser binaries
- Consider Stagehand/Browserbase for cloud browser testing at scale

---

## Alternative: Stagehand/Browserbase

For cloud-based testing or more AI-native approach:

```json
{
  "mcpServers": {
    "browserbase": {
      "command": "npx",
      "args": ["-y", "@browserbase/mcp-server-browserbase"],
      "env": {
        "BROWSERBASE_API_KEY": "${BROWSERBASE_API_KEY}"
      }
    }
  }
}
```

Use when:
- Need cloud browser infrastructure
- Want `act()`, `extract()`, `observe()` primitives
- Scaling to many parallel browsers
